
#' generatePredictionDistributionPlot
#'
#' Generate prediction distribution plot for the given subgroup population.
#'
#' @param plpPrediction       The plpValidationResult object generated by the generateSubgroupValidationData function.
#' @param subgroup            The name of the subgroup. For a binary subgroup, the name is followed by #1 or #0 to determine the subgroup.
#' @param outputFile          The output file path including the file name, such as plot/netbenefit_plot.pdf
#' @return                    It saves and returns the forest plot as a pdf file.
#' @export
generatePredictionDistributionPlot <- function(plpPrediction, subgroup, outputFile){
  if(subgroup == "all") {
    plotDf <- plpPrediction[c("outcomeCount", "value")]
    plotDf$outcomeCount <- as.factor(plotDf$outcomeCount)
  } else if(grepl("#", subgroup)){
    sv <- strsplit(subgroup, split = "#")
    s <- sv[[1]][1]
    v <- as.numeric(sv[[1]][2])
    if (s %in% colnames(plpPrediction) == F){
      stop("Invalid subgroup!")
    }
    plotDf <- plpPrediction[plpPrediction[s] == v,][c("outcomeCount", "value")]
    plotDf$outcomeCount <- as.factor(plotDf$outcomeCount)
  } else {
    stop("Invalid subgroup!")
  }

  violinPlot <- ggplot2::ggplot(
    data = plotDf,
    ggplot2::aes(
      x = .data$outcomeCount,
      y = .data$value
    )
  ) +
    ggplot2::geom_violin(
      ggplot2::aes(fill = outcomeCount),
      show.legend = FALSE
    )  +
    ggplot2::labs(
      x = "Outcome (0, 1)",
      y = "Estimated probability"
    ) +
    ggplot2::geom_boxplot(width=0.1) +
    ggplot2::theme(legend.position = "none",
          axis.title = ggplot2::element_text(size=20),
          text = ggplot2::element_text(size=19))

  plot(violinPlot)
  ggplot2::ggsave(outputFile, units="in", width=6, height=6, dpi=300)
  dev.off()
  return(violinPlot)
}
