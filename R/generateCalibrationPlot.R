#' generateCalibrationPlot
#'
#' Generate calibration plot for the given subgroup population.
#'
#' @param validationResults    The allValidationResults object generated by the generateSubgroupValidationData function.
#' @param smoothMethod         The smooth method when plotting.
#' @param span                 Plot span value.
#' @param se                   If standard error included.
#' @param scatter              If scatter included.
#' @param hist                 If histogram included.
#' @param hist_norm            Normalization value for histogram.
#' @param subgroup             The name of the subgroup. For a binary subgroup, the name is followed by #1 or #0 to determine the subgroup.
#' @param outputFile           The output file path including the file name, such as plot/AUPRC_forest_plot.tiff.
#' @return                     It saves and returns the forest plot as a tiff file.
#' @export
generateCalibrationPlot <- function(
    validationResults,
    smoothMethod = "loess",
    span = 0.75,
    se = T,
    scatter = F,
    hist = T,
    hist_norm = 0.2,
    subgroup = "all",
    outputFile = 'results/plot/calibration.pdf'
) {

  sparsePred <- validationResults$calibrationSummaryTable[validationResults$calibrationSummaryTable$evaluation == subgroup,]
  sparsePred$groupIndex <- rep(1:10, each = 10)
  groupStats <- sparsePred %>% dplyr::group_by(groupIndex) %>% dplyr::summarise(
    predMean = mean(averagePredictedProbability),
    obsMean = mean(observedIncidence),
    obsSe = sd(observedIncidence) / sqrt(dplyr::n())
  )
  groupStats$groupType = as.factor(rep(1,10))

  limVal <- max(
    max(sparsePred$averagePredictedProbability),
    max(sparsePred$observedIncidence)
  )

  cols <- c('value', 'outcomeCount')

  if(subgroup == "all") {
    brierData <- validationResults$plpValidationResult[cols]
  } else if(grepl("#", subgroup)){
    sv <- strsplit(subgroup, split = "#")
    s <- sv[[1]][1]
    v <- as.numeric(sv[[1]][2])
    if (s %in% colnames(validationResults$plpValidationResult) == F){
      stop("Invalid subgroup!")
    }
    brierData <- validationResults$plpValidationResult[validationResults$plpValidationResult[s] == v,][cols]
  } else {
    stop("Invalid subgroup!")
  }

  brier <- round(calcBrierScore(brierData), digits = 2)

  smooth_plot <- ggplot2::ggplot(
    data = sparsePred,
    ggplot2::aes(
      x = .data$averagePredictedProbability,
      y = .data$observedIncidence
    )
  ) +
    ggplot2::stat_smooth(
      ggplot2::aes(
        color = "Model",
        linetype = "Model"
      ),
      method = smoothMethod,
      se = se,
      span = span,
      size = 1,
      show.legend = F
    ) +
    ggplot2::geom_segment(
      ggplot2::aes(
        x = 0,
        xend = 1,
        y = 0,
        yend = 1,
        color = "Ideal",
        linetype = "Ideal"
      )
    ) +
    ggplot2::coord_cartesian(
      xlim = c(0,1),
      ylim = c(-hist_norm,1)
    ) +
    ggplot2::scale_linetype_manual(
      name = "Line Type",
      values = c(Ideal = "dashed", Model = "solid"),
      guide = "none"
    ) +
    ggplot2::scale_color_manual(
      name = "Calibration (Brier)",
      values = c(Ideal = "black", Model = "red"),
      labels = c(Ideal = "Ideal (0.00)", Model = paste0("Model (", brier, ")")),
      breaks = c("Ideal", "Model")
    ) +
    ggplot2::labs(
      x = "Predicted Probability",
      y = "Observed Probability"
    )



  smooth_plot <- smooth_plot +
    ggplot2::geom_pointrange(
      data = groupStats,
      ggplot2::aes(
        x = predMean,
        y = obsMean,
        ymin = obsMean - 1.96 * obsSe,
        ymax = obsMean + 1.96 * obsSe,
        shape = groupType
      ),
      color = "black"
    ) +
    ggplot2::scale_shape_manual(name = NULL,
                           values = c(2),
                           labels = c("Grouped observations"))

  if (scatter) {
    smooth_plot <- smooth_plot +
      ggplot2::geom_point(
        data = sparsePred,
        ggplot2::aes(
          x = .data$averagePredictedProbability,
          y = .data$observedIncidence
        ),
        color = "black",
        size = 2
      )
  }

  if (hist) {
    smooth_plot <- smooth_plot +
      ggplot2::geom_histogram(
        #ggplot2::aes(x =.data$averagePredictedProbability, y = -..density../sum(..density..)),
        ggplot2::aes(x =.data$averagePredictedProbability, y = -(ggplot2::after_stat(density) -  min(ggplot2::after_stat(density))) * hist_norm / (max(ggplot2::after_stat(density)) - min(ggplot2::after_stat(density))) ),
        bins = 50,
        colour = "black",
        fill = "white"
      )
  }

  smooth_plot <- smooth_plot +
          ggplot2::theme(legend.position = c(0.28, 0.83),
          axis.title = ggplot2::element_text(size=22),
          text = ggplot2::element_text(size=19))

  plot(smooth_plot)
  ggplot2::ggsave(outputFile, units="in", width=6, height=6, dpi=300)
  dev.off()
  return(smooth_plot)
}



calcBrierScore <- function(prediction){
  brier <- sum((prediction$outcomeCount - prediction$value)^2)/nrow(prediction)
  return(brier)
}




